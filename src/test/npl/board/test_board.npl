package board

@test
function test_new_board_creation(test: Test) returns Unit {

    var names = listOf(0, 1, 2, 3, 4, 5, 6).map(\(n: Number) returns Text -> n.toText()).toSet();

    var SECRETARY = getSecretaryClaims();
    var BOARD_MEMBER: Party = getBoardMemberClaims(names);
    var CHAIRMAN: Party = getChairmanClaims();

    var board = Board[CHAIRMAN, BOARD_MEMBER, SECRETARY](12);

    board.suggestTopic[SECRETARY]("Should we go eat lunch?");

    test.assertFails(\() -> board.selectedTopicForVote[SECRETARY]("Should we go eat lunch?"));

    var ballot = board.selectedTopicForVote[CHAIRMAN]("Should we go eat lunch?");

    // how to change branches, push & MR on specific branch

    /* ************ Task to complete *********************** */
    // The board has conveined and your task is to decided
    // if it should go for lunch. A ballot has been created
    // for that purpose.
    //
    // Your task is to
    //  - submit 4 votes to the ballot such that it gets
    //    accepted
    //  - count the votes & close the ballot
    //  - analyse the state machine and send Jean a
    //    screenshot thereof
    //
    // For those of you willing to go steps further, it is
    // encouraged to work as a team to define and augment
    // the board features with some (but not limited to)
    // of the following ideas:
    //  - ballot-specific quorum number
    //  - enforce the one-person one-vote equivalence
    //    (people can be represented by their name)
    //  - chairman casting the  decisive vote in case of
    //    tie-break
    //  - super-majority requirements for ballots labelled
    //    as 'budget-relevant'
    //  - any of your idea ;-)
    //
    // For all those features, test should also be implemented!

    /* ************ Implementation starts here ************* */

    for (i in listOfSize(names.size(), \(n: Number) returns Number -> n)) {
        var name = names.toList().get(i);
        var currentParty = getNamedBoardMemberClaims(name);

        var vote_p = Vote[currentParty](if ((i + 1) % 2 == 1) { VotePossibilities.YAY; } else { VotePossibilities.NAY; });
        ballot.vote[currentParty](vote_p);
    };

    ballot.changeNothing[BOARD_MEMBER](); // This command does nothing but updating the protocol version twice!

    ballot.endVote[CHAIRMAN]();

    ballot.triggerCounting[CHAIRMAN]();

    /* ************ Implementation ends here ************** */

    test.assertEquals(7, ballot.votes.size(), "All four members should have voted.");
    test.assertEquals(ballot.states.COUNTED, ballot.currentState, "Ballot should be in state COUNTED at this stage.");
    test.assertTrue(ballot.accepted.isPresent() && ballot.accepted.getOrFail(), "Vote to go for lunch should be accepted.");
};
